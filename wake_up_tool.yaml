esphome:
  name: wake-up-tool
  friendly_name: "PC Wake-Up Tool"
  platformio_options:
    build_flags:
      - "-DARDUINO_USB_CDC_ON_BOOT=0"
      - "-DARDUINO_USB_MODE=0"        # OTG Mode (nicht CDC)
      - "-DCFG_TUD_HID=1"             # TinyUSB HID aktivieren
      - "-DCFG_TUD_ENABLED=1"
  includes:
    - custom_components/usb_keyboard.h
  on_boot:
    priority: 600
    then:
      - lambda: |-
          // USB Keyboard initialisieren
          usb_keyboard_init();

esp32:
  board: esp32-s3-devkitc-1
  variant: esp32s3
  framework:
    type: arduino
    version: recommended

# WiFi Konfiguration
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  # Optional: Fallback AP wenn WiFi nicht erreichbar
  ap:
    ssid: "WakeUpTool-Fallback"
    password: "12345678"

# Home Assistant API
api:
  encryption:
    key: !secret api_encryption_key

# OTA Updates
ota:
  - platform: esphome
    password: !secret ota_password

# Logger (Debug Output)
logger:
  level: DEBUG
  # Hardware Serial auf GPIO 43/44
  hardware_uart: UART1
  baud_rate: 115200

# I2C f√ºr VL53L0X ToF-Sensor
# Freenove ESP32-S3: GPIO14=SDA, GPIO21=SCL
i2c:
  sda: GPIO14
  scl: GPIO21
  frequency: 100kHz
  scan: true

# GPIO f√ºr LED Feedback
output:
  - platform: gpio
    pin: GPIO48
    id: motion_led
  # XSHUT wird jetzt von VL53L0X Komponente via enable_pin verwaltet

# LED als Binary Output (ON/OFF)
light:
  - platform: binary
    name: "Motion Detected LED"
    output: motion_led
    id: motion_indicator

# VL53L0X ToF-Sensor (Distance Measurement)
sensor:
  - platform: vl53l0x
    name: "Distance"
    id: distance_sensor
    update_interval: 500ms  # Mehr Zeit f√ºr stabile Messung
    long_range: false  # Short Range (max 1.3m) - schneller und stabiler
    address: 0x29
    timeout: 200us  # K√ºrzeres Timeout f√ºr schnellere Recovery
    # XSHUT Pin f√ºr korrektes Sensor-Power-Sequencing
    enable_pin: GPIO47

# ============================================
# EINSTELLBARE PARAMETER (in Home Assistant)
# ============================================
number:
  # Cooldown: Wie lange warten bis n√§chster Trigger m√∂glich? (Sekunden)
  - platform: template
    name: "Motion Cooldown"
    id: motion_cooldown
    icon: "mdi:timer-sand"
    unit_of_measurement: "s"
    min_value: 0
    max_value: 300
    step: 5
    initial_value: 5  # 5 Sekunden f√ºr schnelles Testen
    optimistic: true
    restore_value: true

# Binary Sensor f√ºr Motion Detection
# FUNKTIONSWEISE: Sobald eine g√ºltige Distanz gemessen wird = Motion
# Mit Cooldown: Nach einem Trigger wartet es X Sekunden bevor erneut getriggert werden kann
binary_sensor:
  - platform: template
    name: "Motion Detected"
    id: motion_detected
    device_class: motion
    lambda: |-
      static unsigned long last_trigger_time = 0;
      
      float current = id(distance_sensor).state;
      bool object_detected = !isnan(current);
      
      // Kein Objekt = OFF
      if (!object_detected) {
        return false;
      }
      
      // Objekt erkannt! Pr√ºfe Cooldown (zeitbasiert)
      unsigned long cooldown_ms = (unsigned long)(id(motion_cooldown).state * 1000);
      unsigned long now = millis();
      
      // Cooldown seit letztem Trigger noch nicht abgelaufen?
      if ((now - last_trigger_time) < cooldown_ms) {
        return false;  // Noch im Cooldown, ignoriere
      }
      
      // NEUER TRIGGER! 
      last_trigger_time = now;
      ESP_LOGI("motion", "üéØ Motion TRIGGERED! Next allowed in %ds", (int)id(motion_cooldown).state);
      return true;
    
    # Debounce Filter - KEIN delayed_on damit schnelle Erkennung
    filters:
      - delayed_off: 3s  # Bleibt 3s aktiv nach letzter Bewegung
    
    # Bei Motion: LED an + USB Tastendruck senden (wenn aktiviert)
    on_press:
      then:
        - light.turn_on: motion_indicator
        - if:
            condition:
              switch.is_on: usb_wake_enabled
            then:
              - lambda: |-
                  // USB Tastendruck senden um Bildschirm aufzuwecken
                  usb_keyboard_wake_screen();
    on_release:
      then:
        - light.turn_off: motion_indicator

  # Sensor Health Check - pr√ºft ob die VL53L0X KOMPONENTE funktioniert
  # Das ist UNABH√ÑNGIG von NaN (out of range) - pr√ºft den I2C Bus Status
  - platform: template
    name: "Sensor Error"
    id: sensor_error
    device_class: problem
    lambda: |-
      // Pr√ºfe ob die VL53L0X Komponente als FAILED markiert ist
      // Das passiert bei I2C-Fehlern (NACK, Bus blockiert, etc.)
      // NICHT bei normalem "out of range" (NaN)
      return id(distance_sensor).is_failed();

# Restart Button
button:
  - platform: restart
    name: "Reboot"
  
  # Manueller Test-Button f√ºr USB Keyboard Wake
  - platform: template
    name: "Test USB Wake"
    icon: "mdi:keyboard"
    on_press:
      then:
        - lambda: |-
            usb_keyboard_wake_screen();

# Switch um USB-Wake zu aktivieren/deaktivieren
switch:
  - platform: template
    name: "USB Wake Enabled"
    id: usb_wake_enabled
    icon: "mdi:monitor"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON

# Intervall f√ºr automatischen Health-Check und Watchdog
interval:
  - interval: 60s
    then:
      # Nur rebooten wenn Sensor Error binary_sensor aktiv ist
      - lambda: |-
          static int error_minutes = 0;
          if (id(sensor_error).state) {
            error_minutes++;
            ESP_LOGW("WATCHDOG", "Sensor error active for %d minutes", error_minutes);
            // Nach 5 Minuten echtem Fehler automatisch neu starten
            if (error_minutes >= 5) {
              ESP_LOGE("WATCHDOG", "Persistent sensor error, rebooting...");
              App.safe_reboot();
            }
          } else {
            error_minutes = 0;  // Reset wenn Sensor OK
          }
